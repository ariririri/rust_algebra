# Rustで代数的数を作る

最近計算機代数に興味があります.
正確には多重ゼータ等で得られる周期の数論的な解釈や逆にイデアル類群の構造を実現するアルゴリズム自体に興味があります。

そこで代数の王道だと思いますが多項式の最小分解体を求め,そのガロア群を求めることを目指し,Rustで計算したいと思います。

すでに
- [週刊 代数的実数を作る](https://miz-ar.info/math/algebraic-real/)
- [五次元世界の冒険](http://ikumi.que.jp/blog/archives/252)
- [Swiftで代数学入門 ](https://qiita.com/taketo1024/items/bd356c59dc0559ee9a0b)

等様々な素晴らしいサイトがありますが,Rustの理解を含め勉強していこうと思います.

代数拡大をするには多項式環を既約多項式で割った体を考える必要があるので,
しばらくは一変数多項式を定義して,いろいろ実装しようと思います.

今回は最初なので,

- [x] 多項式の定義
- [x] 多項式の表示
- [x] 次数
- [x] 和,差,積,定数倍
- [ ] 割り算(商,余り)
- [ ] GCD
- [ ] 微分
- [x] 値の代入
- [ ] 合成
- [ ] squarefree
- [ ] monic

等をまとめようと思います.

### 多項式の定義
数学上の一変数の多項式とは$\sum a_x x^n$と書かれるもののことです。
プログラム上では一変数の配列(Vector)として定義します.

変数も設定しておきたいので,それも設定しておきます.

特に多項式はただの配列と思わない演算を定義するので型として定義しました.

```rust
struct Poly<T: Num> {
    f: Vec<T>,
}
```
本当は多項式を$x^n$なのか$y^n$なのかいろいろ表し方はあると思いますが,rustは文字列の扱いが大変のため,ひとまずこのままとします.



## 多項式の既約分解
有理数係数の多項式既約な多項式の積に分解します.
方法はいろいろあります.

- Kroneckerの方法
  一番シンプルなものです.もし整数係数多項式$f$が$g$を約数に持っているなら任意の整数$k$に対し.$g(k) | f(k)$となるので,それから$g$として取りうるものを虱潰しに計算する求めて.計算します.
- Cantor-Zassenhausの方法(有限体の場合)
- Berlekampの方法(有限体の場合)
- 大きい素数を使う方法
  大きい素数を使って有限体の場合に帰着させる話
- Henselの補題を使う方法

## 有限体の実現
$p$の場合は簡単だけど,拡大体の場合はどうするんだろうか.

### 有限体の分解方法
有限体のある方程式の最小分解体は次数だけで定まる.
有限体の場合はある既約多項式の最小分解体は次数だけで定まる.
$x^{q^n} - x$の最小分解体は$\mathbb{F}_{q^n}$となるので,

1. $g_0:=f$ とおく。
2. $k=1,2,\ldots $に関して、順番に i.〜iii. を実行する
   - 次の既約因数を全て掃き出すために、次を計算する：
   $$f_k:=\gcd(g_{k-1},x^{q^k}-x)$$
   が ff に含まれる kk 次の既約因数全ての積となる。
   - $g_{k-1}$を$f_k$で割ったものが$g_k$となる：
   $$g_k:=g_{k-1}/f_k$$
​	  は、 k 次の既約因数が全て掃き出され、k+1 次以上の既約因数のみからなる（ff は無平方と仮定していることに注意せよ）。
   - もしも $g_k$が 1 となれば、既約因数を掃き出し終えたということなので、アルゴリズムを停止する。
3. $f=f_1f_2\cdots f_k$であり、$f_i$の既約因数は全て$i$次である。

つまりinductiveに$f$の因数となる既約$k$次多項式を取る.
それは$f$と$x^{q^k} - x$との最大公約数を取れば良い.

これによって$i$次の既約多項式の積となるので,それを求める.

これは$q-1/2$乗すると1 or -1になることを使う.
なのでこの時,1のものと-1のものがあればそれから既約多項式を求めることができる.
全てが0となる場合はもともと0なのでダメなことに注意.


## 代数的数の実現
多項式とその多項式が解を持つ範囲によって多項式を実現する.



## 最小分解体を求めたい
- degree
- mini poly